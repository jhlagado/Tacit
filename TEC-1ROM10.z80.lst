0000                          .ENGINE   mycomputer   
0000                             ; 
0000                TEC_1:    EQU   1   
0000                RC2014:   EQU   0   
0000                EXTENDED:   EQU   0   
0000                          IF   RC2014   
                                 ; Configuration for RC2014
                    ROMSTART:   EQU   $8000   
                    RAMSTART:   EQU   $8800   
                    LOADER:   EQU   0   
                    BITBANG:   EQU   0   
0000                          ENDIF      
0000                          IF   TEC_1   
0000                             ; Configuration for TEC-1
0000                LOADER:   EQU   0   
0000                BITBANG:   EQU   0   
0000                ROMSTART:   EQU   $0000   
0000                RAMSTART:   EQU   $0800   
0000                ROMSIZE:   EQU   $0800   
0000                RAMSIZE:   EQU   $0800   
0000                             ;TEC-1D SC 8k rom/ram
0000                             ; ROMSTART .equ $0000
0000                             ; RAMSTART .equ $2000
0000                             ; ROMSIZE  .equ 8192
0000                             ; RAMSIZE  .equ 8192
0000                          ENDIF      
0000                             ; ROM code
0000                             ; Targets:
0000                             ; TEC-1,TEC-1D,TEC-1F,Southern Cross,RC2014
0000                             ; Memory Map: 2k ROM/RAM, 8K ROM/RAM, RC2014
0000                             ; Serial: Bit Bang, 6850 ACIA
0000                             ; 
0000                          IF   TEC_1   
0000                          IF   BITBANG   
                                 ; 
                                 ; bit bang baud rate constants @ 4MHz
                    B300:     EQU   0220H   
                    B1200:    EQU   0080H   
                    B2400:    EQU   003FH   
                    B4800:    EQU   001BH   
                    B9600:    EQU   000BH   
                                 ; 
0000                          ELSE      ;6850
0000                             ; 
0000                             ; 
0000                             ; 6850 ACIA registers
0000                             ;----------------------
0000                CONTROL:   EQU   $80   ;(write) 
0000                STATUS:   EQU   $80   ;(read)
0000                TDR:      EQU   $81   ;(write)
0000                RDR:      EQU   $81   ;(read)
0000                             ; 
0000                             ; control register bits
0000                             ;----------------------
0000                             ; 
0000                             ;clock divisor
0000                             ; 
0000                MRESET:   EQU   $03   ;master reset the ACIA
0000                             ; DIV_0    .EQU  $00        ;CLOCK/1
0000                             ; DIV_16   .EQU  $01        ;CLOCK/16
0000                DIV_64:   EQU   $02   ;CLOCK/64
0000                             ; 
0000                             ; format select
0000                             ; 
0000                F7E2:     EQU   $00   ;7 data bits, EVEN parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7O2:     EQU   $04   ;7 data bits, ODD parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7E1:     EQU   $08   ;7 data bits, EVEN parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F7O1:     EQU   $0C   ;7 data bits, ODD parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F8N2:     EQU   $10   ;8 data bits, NO parity, 2 stop bits (1+8+0+2= 11 bits)
0000                F8N1:     EQU   $14   ;8 data bits, NO parity, 1 stop bit (1+8+0+1= 10 bits)
0000                F8E1:     EQU   $18   ;8 data bits, EVEN parity, 1 stop bit (1+8+1+1= 11 bits)
0000                F8O1:     EQU   $1C   ;8 data bits, ODD parity,1 stop bit (1+8+1+1= 11 bits)
0000                             ; 
0000                             ; transmitter control
0000                             ; 
0000                RTSLID:   EQU   $00   ;RTS LOW, transmit interrupt disabled
0000                RTSLIE:   EQU   $20   ;RTS LOW, transmit interrupt enabled
0000                RTSHID:   EQU   $40   ;RTS HIGH, transmit interrupt disabled
0000                RTSLIDB:   EQU   $60   ;RTS LOW, transmit interrupt disabled and "break" transmitted
0000                             ; 
0000                             ; receiver interrupt
0000                             ; 
0000                RIE:      EQU   $80   ;receiver interrupt enabled
0000                             ; 
0000                             ; status register bits
0000                             ;---------------------
0000                RDRF:     EQU   0   ;receive data register full
0000                TDRE:     EQU   1   ;transmit data register empty
0000                DCD:      EQU   2   ;data carrier detect
0000                CTS:      EQU   3   ;clear to send
0000                FE:       EQU   4   ;framing error
0000                OVRN:     EQU   5   ;overrun
0000                PE:       EQU   6   ;parity error
0000                IRQ:      EQU   7   ;interrupt request
0000                             ; 
0000                          ENDIF      
0000                          ENDIF      
0000                             ; 
0000                             ; I/O port addresses
0000                             ; 
0000                          IF   TEC_1   
0000                KEYBUF:   EQU   00H   ;MM74C923N KEYBOARD ENCODER
0000                SCAN:     EQU   01H   ;DISPLAY SCAN LATCH
0000                DISPLY:   EQU   02H   ;DISPLAY LATCH
0000                PORT3:    EQU   03H   ;ST3 (8X8), STROBE (RELAY BOARD) DATLATCH (DAT BOARD)
0000                PORT4:    EQU   04H   ;ST4 (8X8), LCD "E" (DAT BOARD)
0000                PORT5:    EQU   05H   
0000                PORT6:    EQU   06H   
0000                PORT7:    EQU   07H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ELSE      ;SC
                    IO0:      EQU   80H   ;IO PORT 0
                    IO1:      EQU   81H   ;IO PORT 1
                    IO2:      EQU   82H   ;IO PORT 2
                    IO3:      EQU   83H   ;IO PORT 3
                    DISPLY:   EQU   84H   ;DISPLAY LATCH
                    SCAN:     EQU   85H   ;DISPLAY SCAN LATCH
                    KEYBUF:   EQU   86H   ;KEYBOARD BUFFER
                    IO7:      EQU   87H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ENDIF      
0000                             ; 
0000                             ; ASCII codes
0000                ESC:      EQU   1BH   
0000                CR:       EQU   0DH   
0000                LF:       EQU   0AH   
0000                             ; 
0000                          .ORG   ROMSTART   
0000                             ;reset
0000                RSTVEC:      
0000   C3 9F 00               JP   RESET   
0003                             ; 
0003                RST1:        
0008                          .ORG   ROMSTART+$08   
0008   F5                     PUSH   af   
0009   3E 01                  LD   a,1   
000B   C3 8C 00               JP   ISR   
000E                             ; 
000E                RST2:        
0010                          .ORG   ROMSTART+$10   
0010   F5                     PUSH   af   
0011   3E 02                  LD   a,2   
0013   C3 8C 00               JP   ISR   
0016                             ; 
0016                RST3:        
0018                          .ORG   ROMSTART+$18   
0018   F5                     PUSH   af   
0019   3E 03                  LD   a,3   
001B   C3 8C 00               JP   ISR   
001E                             ; 
001E                RST4:        
0020                          .ORG   ROMSTART+$20   
0020   F5                     PUSH   af   
0021   3E 04                  LD   a,4   
0023   C3 8C 00               JP   ISR   
0026                             ; 
0026                RST5:        
0028                          .ORG   ROMSTART+$28   
0028   F5                     PUSH   af   
0029   3E 05                  LD   a,5   
002B   C3 8C 00               JP   ISR   
002E                             ; 
002E                RST6:        
0030                          .ORG   ROMSTART+$30   
0030   F5                     PUSH   af   
0031   3E 06                  LD   a,6   
0033   C3 8C 00               JP   ISR   
0036                             ; 
0036                             ;RST 7 Interrupt
0038                          .ORG   ROMSTART+$38   
0038                             ; 
0038                          IF   BITBANG   
                                 ; 
                              PUSH   af   
                              LD   a,7   
                              JP   ISR   
0038                          ELSE      
0038                             ; 
0038   C9                     RET      
0039                             ; 
0039                          ENDIF      
0039                             ; 
0040                          .ORG   ROMSTART+$40   
0040                             ; 
0040                             ;hexadecimal to 7 segment display code table
0040                          IF   TEC_1   
0040                             ; 
0040                SEVENSEGMENT:      
0040   EB 28 CD AD            DB   0EBH,28H,0CDH,0ADH   ;0,1,2,3
0044   2E A7 E7 29            DB   2EH,0A7H,0E7H,29H   ;4,5,6,7
0048   EF 2F 6F E6            DB   0EFH,2FH,6FH,0E6H   ;8,9,A,B
004C   C3 EC C7 47            DB   0C3H,0ECH,0C7H,47H   ;C,D,E,F
0050                          ELSE      ;SC
                                 ; 
                    SEVENSEGMENT:      
                              DB   3FH,06H,5BH,4FH   ;0,1,2,3
                              DB   66H,6DH,7DH,07H   ;4,5,6,7
                              DB   7FH,6FH,77H,7CH   ;8,9,A,B
                              DB   39H,5EH,79H,71H   ;C,D,E,F
0050                          ENDIF      
0050                             ; 
0050                             ; 
0050                             ;---------------
0050                             ; BIT TIME DELAY
0050                             ;---------------
0050                             ;DELAY FOR ONE SERIAL BIT TIME
0050                             ;ENTRY : HL = DELAY TIME
0050                             ; NO REGISTERS MODIFIED
0050                             ; 
0050                PWRUP:       
0050   21 00 20               LD   hl,$2000   
0053                BITIME:      
0053   E5                     PUSH   HL   
0054   D5                     PUSH   DE   
0055   11 01 00               LD   DE,0001H   
0058                BITIM1:      
0058   ED 52                  SBC   HL,DE   
005A   D2 58 00               JP   NC,BITIM1   
005D   D1                     POP   DE   
005E   E1                     POP   HL   
005F                INTRET:      
005F   C9                     RET      
0060                             ; 
0060                             ;RST 8  Non Maskable Interrupt
0066                          .ORG   ROMSTART+$66   
0066   F5                     PUSH   af   
0067   3E 08                  LD   a,8   
0069   C3 8C 00               JP   ISR   
006C                             ; 
006C                             ; 
006C                          IF   BITBANG   
                                 ; 
                                 ;------------------------
                                 ; SERIAL TRANSMIT ROUTINE
                                 ;------------------------
                                 ;TRANSMIT BYTE SERIALLY ON DOUT
                                 ; 
                                 ; ENTRY : A = BYTE TO TRANSMIT
                                 ;  EXIT : NO REGISTERS MODIFIED
                                 ; 
                                 ; 
                    TXCHAR:      
                    TXDATA:      
                              PUSH   AF   
                              PUSH   BC   
                              PUSH   HL   
                              LD   HL,(BAUD)   
                              LD   C,A   
                                 ; 
                                 ; TRANSMIT START BIT
                                 ; 
                              XOR   A   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                                 ; 
                                 ; TRANSMIT DATA
                                 ; 
                              LD   B,08H   
                              RRC   C   
                    NXTBIT:      
                              RRC   C   ;SHIFT BITS TO D6,
                              LD   A,C   ;LSB FIRST AND OUTPUT
                              AND   40H   ;THEM FOR ONE BIT TIME.
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              DJNZ   NXTBIT   
                                 ; 
                                 ; SEND STOP BITS
                                 ; 
                              LD   A,40H   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              CALL   BITIME   
                              POP   HL   
                              POP   BC   
                              POP   AF   
                              RET      
                                 ;-----------------------
                                 ; SERIAL RECEIVE ROUTINE
                                 ;-----------------------
                                 ;RECEIVE SERIAL BYTE FROM DIN
                                 ; 
                                 ; ENTRY : NONE
                                 ;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
                                 ; 
                                 ; REGISTERS MODIFIED A AND F
                                 ; 
                    RXCHAR:      
                    RXDATA:      
                              PUSH   BC   
                              PUSH   HL   
                                 ; 
                                 ; WAIT FOR START BIT 
                                 ; 
                    RXDAT1:   IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;NO START BIT
                                 ; 
                                 ; DETECTED START BIT
                                 ; 
                              LD   HL,(BAUD)   
                              SRL   H   
                              RR   L   ;DELAY FOR HALF BIT TIME
                              CALL   BITIME   
                              IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;START BIT NOT VALID
                                 ; 
                                 ; DETECTED VALID START BIT,READ IN DATA
                                 ; 
                              LD   B,08H   
                    RXDAT2:      
                              LD   HL,(BAUD)   
                              CALL   BITIME   ;DELAY ONE BIT TIME
                              IN   A,(KEYBUF)   
                              RL   A   
                              RR   C   ;SHIFT BIT INTO DATA REG
                              DJNZ   RXDAT2   
                              LD   A,C   
                              OR   A   ;CLEAR CARRY FLAG
                              POP   HL   
                              POP   BC   
                              RET      
                                 ; 
006C                          ELSE      ;6850
006C                             ; 
006C                             ; transmit a character in a
006C                             ;--------------------------
006C                TXDATA:      
006C                TXCHAR:      
006C   C5                     PUSH   bc   
006D   47                     LD   b,a   ;save the character  for later
006E                TXCHAR1:      
006E   DB 80                  IN   a,(STATUS)   ;get the ACIA status
0070   CB 4F                  BIT   1,a   
0072                             ;        bit   TDRE,a                ;is the TDRE bit high?
0072   28 FA                  JR   z,TxChar1   ;no, the TDR is not empty
0074   78                     LD   a,b   ;yes, get the character
0075   D3 81                  OUT   (TDR),a   ;and put it in the TDR
0077   C1                     POP   bc   
0078   C9                     RET      
0079                             ; 
0079                             ; receive  a character in a
0079                             ;---------------------------------
0079                RXDATA:      
0079                RXCHAR:      
0079   DB 80                  IN   a,(STATUS)   ;get the ACIA status
007B   CB 47                  BIT   0,a   
007D                             ;        bit   RDRF,a             ;is the RDRF bit high?
007D   28 FA                  JR   z,RxChar   ;no, the RDR is empty
007F   DB 81                  IN   a,(RDR)   ;yes, read the received char
0081   C9                     RET      
0082                          ENDIF      
0082                             ; 
0082                          IF   LOADER   
                                 ;   .ORG   ROMSTART + $0700
                                 ;-----------------------
                                 ; RECEIVE INTEL HEX FILE
                                 ;-----------------------
                    INTELH:      
                              LD   IX,BUF   
                                 ; 
                                 ; WAIT FOR RECORD MARK
                                 ; 
                    INTEL1:      
                              XOR   A   
                              LD   (IX+3),A   ;CLEAR CHECKSUM
                              CALL   RXDATA   ;WAIT FOR THE RECORD MARK
                              CP   ":"   ;TO BE TRANSMITTED
                              JR   NZ,INTEL1   ;NOT RECORD MARK
                                 ; 
                                 ; GET RECORD LENGTH
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+0),A   ;NUMBER OF DATA BYTES
                                 ; 
                                 ; GET ADDRESS FIELD
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+2),A   ;LOAD ADDRESS HIGH BYTE
                              CALL   GETBYT   
                              LD   (IX+1),A   ;LOAD ADDRESS LOW BYTE
                                 ; 
                                 ; GET RECORD TYPE
                                 ; 
                              CALL   GETBYT   
                              JR   NZ,INTEL4   ;END OF FILE RECORD
                                 ; 
                                 ; READ IN THE DATA
                                 ; 
                              LD   B,(IX+0)   ;NUMBER OF DATA BYTES
                              LD   H,(IX+2)   ;LOAD ADDRESS HIGH BYTE
                              LD   L,(IX+1)   ;LOAD ADDRESS LOW BYTE
                                 ; 
                    INTEL2:      
                              CALL   GETBYT   ;GET DATA BYTE
                              LD   (HL),A   ;STORE DATA BYTE
                              INC   HL   
                              DJNZ   INTEL2   ;LOAD MORE BYTES
                                 ; 
                                 ; GET CHECKSUM AND COMPARE
                                 ; 
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE RECORD CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              JR   Z,INTEL1   ;CHECKSUM OK,NEXT RECORD
                              RET      ;NZ=CHECKSUM ERROR
                                 ; 
                                 ; END OF FILE RECORD
                                 ; 
                    INTEL4:      
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE EOF CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              RET      ;NZ=CHECKSUM ERROR
                                 ;--------------------------
                                 ; GET BYTE FROM SERIAL PORT
                                 ;--------------------------
                    GETBYT:      
                              PUSH   BC   
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT1   
                              ADD   A,09H   
                    GETBT1:      
                              AND   0FH   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              LD   C,A   
                                 ; 
                                 ; GET LOW NYBBLE
                                 ; 
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT2   
                              ADD   A,09H   
                    GETBT2:   AND   0FH   
                              OR   C   
                              LD   B,A   
                              ADD   A,(IX+3)   
                              LD   (IX+3),A   ;ADD TO CHECKSUM
                              LD   A,B   
                              AND   A   ;CLEAR CARRY
                              POP   BC   
                              RET      
0082                          ENDIF      
0082                             ; 
0082                             ; in this example code just wait for an INTEL Hex file download
0082                             ;just going to send a char to let you know I'm here
0082                          IF   LOADER   
                                 ; 
                    LOAD:        
                              LD   a,"L"   ; L for load
                              CALL   TxChar   
                              CALL   INTELH   
                              JP   z,RAMSTART   ;assume the downloaded code starts here
                              LD   a,"0"   ;0 is false
                              CALL   TxChar   
                              JR   load   ;if at first you don't succeed...
0082                          ENDIF      
0082                             ; 
0082                GETCHAR:      
0082   2A 18 0A               LD   HL,(GETCVEC)   
0085   E9                     JP   (HL)   
0086                             ; 
0086                PUTCHAR:      
0086   E5                     PUSH   HL   
0087   2A 1A 0A               LD   HL,(PUTCVEC)   
008A   E3                     EX   (SP),HL   
008B   C9                     RET      
008C                             ; 
008C                ISR:         
008C                             ; assume that IX and IY are ALWAYS valid
008C                             ; may need to disable interrupts during rpush etc
008C                             ; 
008C   C5                     PUSH   bc   
008D   D5                     PUSH   de   
008E   E5                     PUSH   hl   
008F                             ; 
008F   26 00                  LD   h,0   
0091   6F                     LD   l,a   
0092   22 92 0C               LD   (vIntID),hl   
0095                             ; 
0095   CD 53 03               CALL   enter   
0098   5A 00                  .CSTR   "Z"   
009A                             ; 
009A   E1                     POP   hl   
009B   D1                     POP   de   
009C   C1                     POP   bc   
009D                             ; 
009D   F1                     POP   af   
009E                             ; 
009E   C9                     RET      
009F                             ; 
009F                RESET:       
009F   31 00 0A               LD   SP,stack   
00A2   21 79 00               LD   HL,RXDATA   
00A5   22 18 0A               LD   (GETCVEC),HL   
00A8   21 6C 00               LD   HL,TXDATA   
00AB   22 1A 0A               LD   (PUTCVEC),HL   
00AE                             ; 
00AE                          IF   TEC_1   
00AE                          IF   BITBANG = 0   
00AE                             ; 
00AE   3E 03                  LD   a,MRESET   
00B0   D3 80                  OUT   (CONTROL),a   ;reset the ACIA
00B2                             ; 
00B2                          ENDIF      
00B2                          ENDIF      
00B2                             ; 
00B2   CD 50 00               CALL   PWRUP   
00B5   ED 56                  IM   1   
00B7   FB                     EI      
00B8                             ; 
00B8                          IF   TEC_1   
00B8                          IF   BITBANG   
                                 ; 
                                 ;inline serial initialisation
                              LD   A,$40   
                              LD   C,SCAN   
                              OUT   (C),A   
                              LD   HL,B4800   
                              LD   (BAUD),HL   
                                 ; 
00B8                          ELSE      ;6850      
00B8                             ; 
00B8   3E 12                  LD   a,RTSLID+F8N2+DIV_64   
00BA   D3 80                  OUT   (CONTROL),a   ;initialise ACIA  8 bit word, No parity 2 stop divide by 64 for 115200 baud
00BC                             ; 
00BC                          ENDIF      
00BC                          ENDIF      
00BC                             ; 
00BC                             ; 
00BC                             ; 
00BC   C3 D4 01               JP   start   ; into #180 of the prog
00BF                             ; 
00BF                             ; *************************************************************************
00BF                             ; 
00BF                             ;       TACIT Programming Language Z80 v1.0
00BF                             ; 
00BF                             ;       by John Hardy 2024
00BF                             ; 
00BF                             ;       GNU GENERAL PUBLIC LICENSE                   Version 3, 29 June 2007
00BF                             ;       see the LICENSE file in this repo for more information
00BF                             ; 
00BF                             ;       incorporates code by Craig Jones and Ken Boak
00BF                             ; 
00BF                             ; *****************************************************************************
00BF                TRUE:     EQU   -1   
00BF                FALSE:    EQU   0   
00BF                UNLIMITED:   EQU   -1   
00BF                CTRL_C:   EQU   3   
00BF                CTRL_H:   EQU   8   
00BF                BSLASH:   EQU   $5c   
00BF                .macro LITDAT,len
00BF                             ; 
00BF                 db len
00BF                .endm
00BF                 
00BF                .macro REPDAT,len,data
00BF                             ; 
00BF                 db (len | $80)
00BF                 db data
00BF                .endm
00BF                 
00BF                .macro ENDDAT,
00BF                             ; 
00BF                 db 0
00BF                .endm
00BF                 
00BF                             ; **************************************************************************
00BF                             ; Page 0  Initialisation
00BF                             ; **************************************************************************		
0180                          .ORG   ROMSTART + $180   ; 0+180 put TACIT code from here	
0180                IOPCODES:      
0180                          ;*Macro unroll:  LITDAT 15
0180   0F                     DB   15   
0181   00                     DB   lsb(bang_)   ;   !
0182   00                     DB   lsb(dquote_)   ;   "
0183   00                     DB   lsb(hash_)   ;   #
0184   00                     DB   lsb(dollar_)   ;   $
0185   00                     DB   lsb(percent_)   ;   %
0186   00                     DB   lsb(amper_)   ;   &
0187   00                     DB   lsb(quote_)   ;   '
0188   00                     DB   lsb(lparen_)   ;   (
0189   00                     DB   lsb(rparen_)   ;   )
018A   00                     DB   lsb(star_)   ;   *
018B   00                     DB   lsb(plus_)   ;   +
018C   00                     DB   lsb(comma_)   ;   ,
018D   00                     DB   lsb(minus_)   ;   -
018E   00                     DB   lsb(dot_)   ;   .
018F   00                     DB   lsb(slash_)   ;   /	
0190                          ;*Macro unroll:  REPDAT 10, lsb(num_)	; 10 x repeat lsb of add to the num routine
0190   8A                     DB   (10 | $80)   ; 10 x repeat lsb of add to the num routine
0191   00                     DB   lsb(num_)   
0192                          ;*Macro unroll:  LITDAT 7
0192   07                     DB   7   
0193   00                     DB   lsb(colon_)   ;    :
0194   00                     DB   lsb(semi_)   ;    ;
0195   00                     DB   lsb(lt_)   ;    <
0196   00                     DB   lsb(eq_)   ;    =
0197   00                     DB   lsb(gt_)   ;    >
0198   00                     DB   lsb(question_)   ;    ?
0199   00                     DB   lsb(at_)   ;    @
019A                          ;*Macro unroll:  REPDAT 26, lsb(call_)	; call a command a, B ....Z
019A   9A                     DB   (26 | $80)   ; call a command a, B ....Z
019B   00                     DB   lsb(call_)   
019C                          ;*Macro unroll:  LITDAT 6
019C   06                     DB   6   
019D   00                     DB   lsb(lbrack_)   ;    [
019E   00                     DB   lsb(bslash_)   ;    \
019F   00                     DB   lsb(rbrack_)   ;    ]
01A0   00                     DB   lsb(caret_)   ;    ^
01A1   00                     DB   lsb(underscore_)   ;    _
01A2   00                     DB   lsb(grave_)   ;    `   ; for printing `hello`
01A3                          ;*Macro unroll:  REPDAT 26, lsb(var_)	; a b c .....z
01A3   9A                     DB   (26 | $80)   ; a b c .....z
01A4   00                     DB   lsb(var_)   
01A5                          ;*Macro unroll:  LITDAT 4
01A5   04                     DB   4   
01A6   00                     DB   lsb(lbrace_)   ;    {
01A7   00                     DB   lsb(pipe_)   ;    |
01A8   00                     DB   lsb(rbrace_)   ;    }
01A9   00                     DB   lsb(tilde_)   ;    ~ ( a b c -- b c a ) rotate
01AA                IALTCODES:      
01AA                          ;*Macro unroll:  LITDAT 26
01AA   1A                     DB   26   
01AB   00                     DB   lsb(aNop_)   ;A
01AC   00                     DB   lsb(aNop_)   ;B
01AD   00                     DB   lsb(aNop_)   ;C
01AE   00                     DB   lsb(aNop_)   ;D
01AF   00                     DB   lsb(aNop_)   ;E
01B0   00                     DB   lsb(aNop_)   ;F
01B1   00                     DB   lsb(aNop_)   ;G
01B2   00                     DB   lsb(aNop_)   ;H
01B3   00                     DB   lsb(aNop_)   ;I
01B4   00                     DB   lsb(aNop_)   ;J
01B5   00                     DB   lsb(aNop_)   ;K
01B6   00                     DB   lsb(aNop_)   ;L
01B7   00                     DB   lsb(aNop_)   ;M
01B8   00                     DB   lsb(aNop_)   ;N
01B9   00                     DB   lsb(aNop_)   ;O
01BA   00                     DB   lsb(aNop_)   ;P
01BB   00                     DB   lsb(aNop_)   ;Q
01BC   00                     DB   lsb(aNop_)   ;R
01BD   00                     DB   lsb(aNop_)   ;S
01BE   00                     DB   lsb(aNop_)   ;T
01BF   00                     DB   lsb(aNop_)   ;U
01C0   00                     DB   lsb(aNop_)   ;V
01C1   00                     DB   lsb(aNop_)   ;W
01C2   00                     DB   lsb(aNop_)   ;X
01C3   00                     DB   lsb(aNop_)   ;Y
01C4   00                     DB   lsb(aNop_)   ;Z
01C5                          ;*Macro unroll:  ENDDAT
01C5   00                     DB   0   
01C6                BACKSPACE:      
01C6   79                     LD   a,c   
01C7   B0                     OR   b   
01C8   28 28                  JR   z,interpret2   
01CA   0B                     DEC   bc   
01CB   CD 24 03               CALL   printStr   
01CE   08 20 08 00            .CSTR   "\b \b"   
01D2   18 1E                  JR   interpret2   
01D4                START:       
01D4   31 00 0A               LD   SP,DSTACK   ; start of TACIT
01D7   CD 70 02               CALL   init   ; setups
01DA   CD 24 03               CALL   printStr   ; prog count to stack, put code line 235 on stack then call print
01DD   54 41 43 49 54 31 2E 30 0D 0A 00 .CSTR   "TACIT1.0\r\n"   
01E8                INTERPRET:      
01E8   CD 14 03               CALL   prompt   
01EB   01 00 00               LD   bc,0   ; load bc with offset into TIB, decide char into tib or execute or control
01EE   ED 43 7C 0C            LD   (vTIBPtr),bc   
01F2                INTERPRET2:      ; calc nesting (a macro might have changed it)
01F2   1E 00                  LD   E,0   ; initilize nesting value
01F4   C5                     PUSH   bc   ; save offset into TIB,
01F5                             ; bc is also the count of chars in TIB
01F5   21 00 08               LD   hl,TIB   ; hl is start of TIB
01F8   18 06                  JR   interpret4   
01FA                INTERPRET3:      
01FA   7E                     LD   a,(hl)   ; A = char in TIB
01FB   23                     INC   hl   ; inc pointer into TIB
01FC   0B                     DEC   bc   ; dec count of chars in TIB
01FD   CD ED 02               CALL   nesting   ; update nesting value
0200                INTERPRET4:      
0200   79                     LD   a,C   ; is count zero?
0201   B0                     OR   B   
0202   20 F6                  JR   NZ,interpret3   ; if not loop
0204   C1                     POP   bc   ; restore offset into TIB
0205                WAITCHAR:      
0205   CD 82 00               CALL   getchar   ; loop around waiting for character from serial port
0208   FE 20                  CP   $20   ; compare to space
020A   30 0E                  JR   NC,waitchar1   ; if >= space, if below 20 set cary flag
020C   FE 00                  CP   $0   ; is it end of string? null end of string
020E   28 2E                  JR   Z,waitchar4   
0210   FE 0D                  CP   "\r"   ; carriage return? ascii 13
0212   28 14                  JR   Z,waitchar3   ; if anything else its macro/control
0214   FE 08                  CP   CTRL_H   
0216   28 AE                  JR   z,backSpace   
0218   18 D8                  JR   interpret2   
021A                WAITCHAR1:      
021A   21 00 08               LD   hl,TIB   
021D   09                     ADD   hl,bc   
021E   77                     LD   (hl),A   ; store the character in textbuf
021F   03                     INC   bc   
0220   CD 86 00               CALL   putchar   ; echo character to screen
0223   CD ED 02               CALL   nesting   
0226   18 DD                  JR   waitchar   ; wait for next character
0228                WAITCHAR3:      
0228   21 00 08               LD   hl,TIB   
022B   09                     ADD   hl,bc   
022C   36 0D                  LD   (hl),"\r"   ; store the crlf in textbuf
022E   23                     INC   hl   
022F   36 0A                  LD   (hl),"\n"   
0231   23                     INC   hl   ; ????
0232   03                     INC   bc   
0233   03                     INC   bc   
0234   CD 1D 03               CALL   crlf   ; echo character to screen
0237   7B                     LD   a,E   ; if zero nesting append and ETX after \r
0238   B7                     OR   A   
0239   20 CA                  JR   NZ,waitchar   
023B   36 03                  LD   (hl),$03   ; store end of text ETX in text buffer
023D   03                     INC   bc   
023E                WAITCHAR4:      
023E   ED 43 7C 0C            LD   (vTIBPtr),bc   
0242   01 00 08               LD   bc,TIB   ; Instructions stored on heap at address HERE, we pressed enter
0245   0B                     DEC   bc   
0246                NEXT:        
0246   03                     INC   bc   ; Increment the IP
0247   0A                     LD   a,(bc)   ; Get the next character and dispatch
0248   B7                     OR   a   ; is it NUL?
0249   28 0F                  JR   z,exit   
024B   FE 03                  CP   CTRL_C   
024D   28 15                  JR   z,etx   
024F   D6 21                  SUB   "!"   
0251   38 F3                  JR   c,NEXT   
0253   6F                     LD   L,A   ; Index into table
0254   26 0B                  LD   H,msb(opcodes)   ; Start address of jump table
0256   6E                     LD   L,(hl)   ; get low jump address
0257   26 04                  LD   H,msb(page4)   ; Load H with the 1st page address
0259   E9                     JP   (hl)   ; Jump to routine
025A                EXIT:        
025A   03                     INC   bc   ; store offests into a table of bytes, smaller
025B   50 59                  LD   de,bc   
025D   CD 41 03               CALL   rpop   ; Restore Instruction pointer
0260   44 4D                  LD   bc,hl   
0262   EB                     EX   de,hl   
0263   E9                     JP   (hl)   
0264                ETX:         
0264   21 00 F6               LD   hl,-DSTACK   ; check if stack pointer is underwater
0267   39                     ADD   hl,SP   
0268   30 03                  JR   NC,etx1   
026A   31 00 0A               LD   SP,DSTACK   
026D                ETX1:        
026D   C3 E8 01               JP   interpret   
0270                INIT:        
0270   DD 21 80 09            LD   IX,RSTACK   
0274   FD 21 46 02            LD   IY,NEXT   ; IY provides a faster jump to NEXT
0278   21 00 0C               LD   hl,vars   
027B   54 5D                  LD   de,hl   
027D   13                     INC   de   
027E   36 00                  LD   (hl),0   
0280   01 9C 00               LD   bc,VARS_SIZE * 3   ; init vars, defs and altVars
0283   ED B0                  LDIR      
0285   21 00 0A               LD   hl,dStack   
0288   22 8C 0C               LD   (vStkStart),hl   
028B   21 41 00               LD   hl,65   
028E   22 9A 0C               LD   (vLastDef),hl   
0291   21 A0 0C               LD   hl,HEAP   
0294   22 76 0C               LD   (vHeapPtr),hl   
0297                INITOPS:      
0297   21 80 01               LD   hl,iOpcodes   
029A   11 00 0B               LD   de,opcodes   
029D   01 78 00               LD   bc,$80-32-1-1+26   
02A0                INITOPS1:      
02A0   7E                     LD   a,(hl)   
02A1   23                     INC   hl   
02A2   CB 27                  SLA   A   
02A4   C8                     RET   Z   
02A5   38 09                  JR   C,initOps2   
02A7   CB 3F                  SRL   A   
02A9   4F                     LD   C,A   
02AA   06 00                  LD   B,0   
02AC   ED B0                  LDIR      
02AE   18 F0                  JR   initOps1   
02B0                INITOPS2:      
02B0   CB 3F                  SRL   A   
02B2   47                     LD   B,A   
02B3   7E                     LD   a,(hl)   
02B4   23                     INC   hl   
02B5                INITOPS2A:      
02B5   12                     LD   (de),A   
02B6   13                     INC   de   
02B7   10 FC                  DJNZ   initOps2a   
02B9   18 E5                  JR   initOps1   
02BB                LOOKUPREF0:      
02BB   21 34 0C               LD   hl,defs   
02BE   D6 41                  SUB   "A"   
02C0   18 02                  JR   lookupRef1   
02C2                LOOKUPREF:      
02C2   D6 61                  SUB   "a"   
02C4                LOOKUPREF1:      
02C4   87                     ADD   a,a   
02C5   85                     ADD   a,l   
02C6   6F                     LD   l,a   
02C7   3E 00                  LD   a,0   
02C9   8C                     ADC   a,h   
02CA   67                     LD   h,a   
02CB   AF                     XOR   a   
02CC   B3                     OR   e   ; sets Z flag if A-Z
02CD   C9                     RET      
02CE                PRINTHEX:      
02CE                             ; Display hl as a 16-bit number in hex.
02CE   C5                     PUSH   bc   ; preserve the IP
02CF   7C                     LD   a,H   
02D0   CD D9 02               CALL   printhex2   
02D3   7D                     LD   a,L   
02D4   CD D9 02               CALL   printhex2   
02D7   C1                     POP   bc   
02D8   C9                     RET      
02D9                PRINTHEX2:      
02D9   4F                     LD   C,A   
02DA   1F                     RRA      
02DB   1F                     RRA      
02DC   1F                     RRA      
02DD   1F                     RRA      
02DE   CD E2 02               CALL   printhex3   
02E1   79                     LD   a,C   
02E2                PRINTHEX3:      
02E2   E6 0F                  AND   0x0F   
02E4   C6 90                  ADD   a,0x90   
02E6   27                     DAA      
02E7   CE 40                  ADC   a,0x40   
02E9   27                     DAA      
02EA   C3 86 00               JP   putchar   
02ED                             ; **************************************************************************
02ED                             ; calculate nesting value
02ED                             ; A is char to be tested,
02ED                             ; E is the nesting value (initially 0)
02ED                             ; E is increased by ( and [
02ED                             ; E is decreased by ) and ]
02ED                             ; E has its bit 7 toggled by `
02ED                             ; limited to 127 levels
02ED                             ; **************************************************************************
02ED                NESTING:      
02ED   FE 60                  CP   "`"   
02EF   20 05                  JR   NZ,nesting1   
02F1   3E 80                  LD   a,$80   
02F3   AB                     XOR   e   
02F4   5F                     LD   e,a   
02F5   C9                     RET      
02F6                NESTING1:      
02F6   CB 7B                  BIT   7,E   
02F8   C0                     RET   NZ   
02F9   FE 3A                  CP   ":"   
02FB   28 08                  JR   Z,nesting2   
02FD   FE 5B                  CP   "["   
02FF   28 04                  JR   Z,nesting2   
0301   FE 28                  CP   "("   
0303   20 02                  JR   NZ,nesting3   
0305                NESTING2:      
0305   1C                     INC   E   
0306   C9                     RET      
0307                NESTING3:      
0307   FE 3B                  CP   ";"   
0309   28 07                  JR   Z,nesting4   
030B   FE 5D                  CP   "]"   
030D   28 03                  JR   Z,nesting4   
030F   FE 29                  CP   ")"   
0311   C0                     RET   NZ   
0312                NESTING4:      
0312   1D                     DEC   E   
0313   C9                     RET      
0314                PROMPT:      
0314   CD 24 03               CALL   printStr   
0317   0D 0A 3E 20 00         .CSTR   "\r\n> "   
031C   C9                     RET      
031D                CRLF:        
031D   CD 24 03               CALL   printStr   
0320   0D 0A 00               .CSTR   "\r\n"   
0323   C9                     RET      
0324                PRINTSTR:      
0324   E3                     EX   (SP),hl   ; swap			
0325   CD 2F 03               CALL   putStr   
0328   23                     INC   hl   ; inc past null
0329   E3                     EX   (SP),hl   ; put it back	
032A   C9                     RET      
032B                PUTSTR0:      
032B   CD 86 00               CALL   putchar   
032E   23                     INC   hl   
032F                PUTSTR:      
032F   7E                     LD   a,(hl)   
0330   B7                     OR   A   
0331   20 F8                  JR   NZ,putStr0   
0333   C9                     RET      
0334                RPUSH:       
0334   F3                     DI      
0335   DD 2B                  DEC   IX   
0337   DD 74 00               LD   (IX+0),H   
033A   DD 2B                  DEC   IX   
033C   DD 75 00               LD   (IX+0),L   
033F   FB                     EI      
0340   C9                     RET      
0341                RPOP:        
0341   F3                     DI      
0342   DD 6E 00               LD   L,(IX+0)   
0345   DD 23                  INC   IX   
0347   DD 66 00               LD   H,(IX+0)   
034A   DD 23                  INC   IX   
034C   FB                     EI      
034D   C9                     RET      
034E                WRITECHAR:      
034E   77                     LD   (hl),A   
034F   23                     INC   hl   
0350   C3 86 00               JP   putchar   
0353                ENTER:       
0353   60 69                  LD   hl,bc   
0355   CD 34 03               CALL   rpush   ; save Instruction Pointer
0358   C1                     POP   bc   
0359   0B                     DEC   bc   
035A   FD E9                  JP   (iy)   
035C                CARRY:       
035C   21 00 00               LD   hl,0   
035F   CB 15                  RL   l   
0361   22 6C 0C               LD   (vCarry),hl   
0364   FD E9                  JP   (iy)   
0366                SETBYTEMODE:      
0366   3E FF                  LD   a,$FF   
0368   18 01                  JR   assignByteMode   
036A                RESETBYTEMODE:      
036A   AF                     XOR   a   
036B                ASSIGNBYTEMODE:      
036B   32 6A 0C               LD   (vByteMode),a   
036E   32 6B 0C               LD   (vByteMode+1),a   
0371   FD E9                  JP   (iy)   
0373                FALSE_:      
0373   21 00 00               LD   hl,FALSE   
0376   18 03                  JR   true1   
0378                TRUE_:       
0378   21 FF FF               LD   hl,TRUE   
037B                TRUE1:       
037B   E5                     PUSH   hl   
037C   FD E9                  JP   (iy)   
037E                             ; **********************************************************************			
037E                             ; Page 4 primitive routines
037E                             ; **********************************************************************
037E                          ALIGN   $100   
0400                PAGE4:       
0400                QUOTE_:      ; Discard the top member of the stack
0400                AT_:         
0400                UNDERSCORE_:      
0400                BSLASH_:      
0400                VAR_:        
0400                BANG_:       ; Store the value at the address placed on the top of the stack
0400                AMPER_:      
0400                PIPE_:       
0400                CARET_:      
0400                TILDE_:      
0400                PLUS_:       ; add the top 2 members of the stack
0400                CALL_:       
0400                DOT_:        
0400                COMMA_:      ; print hexadecimal
0400                DQUOTE_:      
0400                EQ_:         
0400                PERCENT_:      
0400                SEMI_:       
0400                GT_:         
0400                LBRACE_:      
0400                RBRACE_:      
0400                LT_:         
0400                DOLLAR_:      
0400                MINUS_:      ; Subtract the value 2nd on stack from top of stack
0400                GRAVE_:      
0400                LBRACK_:      
0400                NUM_:        
0400                RPAREN_:      
0400                RBRACK_:      
0400                COLON_:      
0400                LPAREN_:      
0400                QUESTION_:      
0400                HASH_:       
0400                STAR_:       
0400                SLASH_:      
0400                ALT_:        
0400   FD E9                  JP   (iy)   
0402                             ; **************************************************************************
0402                             ; Page 6 Alt primitives
0402                             ; **************************************************************************
0402                          ALIGN   $100   
0500                PAGE6:       
0500                ANOP_:       
0500   FD E9                  JP   (iy)   
0502                FALSEX_:      
0502   C3 73 03               JP   false_   
0505                PRINTCHAR_:      
0505   E1                     POP   hl   
0506   7D                     LD   a,L   
0507   CD 86 00               CALL   putchar   
050A   FD E9                  JP   (iy)   
050C                TRUEX_:      
050C   C3 78 03               JP   true_   
050F                             ;*******************************************************************
050F                             ; Subroutines
050F                             ;*******************************************************************
050F                             ; hl = value
050F                PRINTDEC:      
050F   CB 7C                  BIT   7,h   
0511   28 0B                  JR   z,printDec2   
0513   3E 2D                  LD   a,"-"   
0515   CD 86 00               CALL   putchar   
0518   AF                     XOR   a   
0519   95                     SUB   l   
051A   6F                     LD   l,a   
051B   9F                     SBC   a,a   
051C   94                     SUB   h   
051D   67                     LD   h,a   
051E                PRINTDEC2:      
051E   C5                     PUSH   bc   
051F   0E 00                  LD   c,0   ; leading zeros flag = false
0521   11 F0 D8               LD   de,-10000   
0524   CD 40 05               CALL   printDec4   
0527   11 18 FC               LD   de,-1000   
052A   CD 40 05               CALL   printDec4   
052D   11 9C FF               LD   de,-100   
0530   CD 40 05               CALL   printDec4   
0533   1E F6                  LD   e,-10   
0535   CD 40 05               CALL   printDec4   
0538   0C                     INC   c   ; flag = true for at least digit
0539   1E FF                  LD   e,-1   
053B   CD 40 05               CALL   printDec4   
053E   C1                     POP   bc   
053F   C9                     RET      
0540                PRINTDEC4:      
0540   06 2F                  LD   b,"0"-1   
0542                PRINTDEC5:      
0542   04                     INC   b   
0543   19                     ADD   hl,de   
0544   38 FC                  JR   c,printDec5   
0546   ED 52                  SBC   hl,de   
0548   3E 30                  LD   a,"0"   
054A   B8                     CP   b   
054B   20 05                  JR   nz,printDec6   
054D   AF                     XOR   a   
054E   B1                     OR   c   
054F   C8                     RET   z   
0550   18 01                  JR   printDec7   
0552                PRINTDEC6:      
0552   0C                     INC   c   
0553                PRINTDEC7:      
0553   78                     LD   a,b   
0554   C3 86 00               JP   putchar   
0557                             ;*******************************************************************
0557                             ; Page 5 primitive routines continued
0557                             ;*******************************************************************
0557                NUM:         
0557   21 00 00               LD   hl,$0000   ; Clear hl to accept the number
055A   0A                     LD   a,(bc)   ; Get numeral or -
055B   FE 2D                  CP   "-"   
055D   20 01                  JR   nz,num0   
055F   03                     INC   bc   ; move to next char, no flags affected
0560                NUM0:        
0560   08                     EX   af,af'   ; save zero flag = 0 for later
0561                NUM1:        
0561   0A                     LD   a,(bc)   ; read digit
0562   D6 30                  SUB   "0"   ; less than 0?
0564   38 13                  JR   c,num2   ; not a digit, exit loop
0566   FE 0A                  CP   10   ; greater that 9?
0568   30 0F                  JR   nc,num2   ; not a digit, exit loop
056A   03                     INC   bc   ; inc IP
056B   54 5D                  LD   de,hl   ; multiply hl * 10
056D   29                     ADD   hl,hl   
056E   29                     ADD   hl,hl   
056F   19                     ADD   hl,de   
0570   29                     ADD   hl,hl   
0571   85                     ADD   a,l   ; add digit in a to hl
0572   6F                     LD   l,a   
0573   3E 00                  LD   a,0   
0575   8C                     ADC   a,h   
0576   67                     LD   h,a   
0577   18 E8                  JR   num1   
0579                NUM2:        
0579   0B                     DEC   bc   
057A   08                     EX   af,af'   ; restore zero flag
057B   20 07                  JR   nz,num3   
057D   EB                     EX   de,hl   ; negate the value of hl
057E   21 00 00               LD   hl,0   
0581   B7                     OR   a   ; jump to sub2
0582   ED 52                  SBC   hl,de   
0584                NUM3:        
0584   E5                     PUSH   hl   ; Put the number on the stack
0585   FD E9                  JP   (iy)   ; and process the next character
0587                             ; *******************************************************************************
0587                             ; *********  END OF MAIN   ******************************************************
0587                             ; *******************************************************************************
0587                             ; *******************************************************************************
0587                DSIZE:    EQU   $80   
0587                RSIZE:    EQU   $80   
0587                TIBSIZE:   EQU   $100   ; 256 bytes , along line!
0587                VARS_SIZE:   EQU   26*2   
0800                          .ORG   RAMSTART   
0800                TIB:      DS   TIBSIZE   
0900                          DS   RSIZE   
0980                RSTACK:      
0980                          DS   DSIZE   
0A00                DSTACK:      
0A00                STACK:       
0A00                TBPTR:    DS   2   ; reserved for tests
0A02                VTEMP1:   DS   2   ; 
0A04                VTEMP2:   DS   2   ; 
0A06                RST08:    DS   2   
0A08                RST10:    DS   2   
0A0A                RST18:    DS   2   
0A0C                RST20:    DS   2   
0A0E                RST28:    DS   2   
0A10                RST30:    DS   2   ; 
0A12                BAUD:     DS   2   ; 
0A14                INTVEC:   DS   2   ; 
0A16                NMIVEC:   DS   2   ; 
0A18                GETCVEC:   DS   2   ; 
0A1A                PUTCVEC:   DS   2   ; 
0A1C                          ALIGN   $100   
0B00                OPCODES:      
0B00                          DS   $80-32-1-1   
0B5E                ALTCODES:      
0B5E                          DS   26   
0B78                          ALIGN   $100   
0C00                VARS:     DS   VARS_SIZE   
0C34                DEFS:     DS   VARS_SIZE   
0C68                ALTVARS:      
0C68                          DS   2   ; a
0C6A                VBYTEMODE:   DS   2   ; b
0C6C                VCARRY:   DS   2   ; c carry variable
0C6E                          DS   2   ; d
0C70                          DS   2   ; e
0C72                VINTFUNC:   DS   2   ; f interrupt func
0C74                          DS   2   ; g
0C76                VHEAPPTR:   DS   2   ; h heap pointer variable
0C78                          DS   2   ; i loop variable
0C7A                          DS   2   ; j outer loop variable
0C7C                VTIBPTR:   DS   2   ; k address of text input buffer
0C7E                          DS   2   ; l
0C80                          DS   2   ; m
0C82                          DS   2   ; n
0C84                          DS   2   ; o
0C86                          DS   2   ; p
0C88                          DS   2   ; q
0C8A                VREMAIN:   DS   2   ; r remainder of last division
0C8C                VSTKSTART:   DS   2   ; s address of start of stack
0C8E                          DS   2   ; t
0C90                          DS   2   ; u
0C92                VINTID:   DS   2   ; v interrupt id
0C94                          DS   2   ; w
0C96                          DS   2   ; x
0C98                          DS   2   ; y
0C9A                VLASTDEF:   DS   2   ; z name of last defined function
0C9C                VPOINTER:   DS   2   ; 
0C9E                VELSE:    DS   2   ; 
0CA0                HEAP:        


TEC_1:              0001 DEFINED AT LINE 1 IN constants.asm
RC2014:             0000 DEFINED AT LINE 2 IN constants.asm
EXTENDED:           0000 DEFINED AT LINE 4 IN constants.asm
LOADER:             0000 DEFINED AT LINE 20 IN constants.asm
BITBANG:            0000 DEFINED AT LINE 21 IN constants.asm
ROMSTART:           0000 DEFINED AT LINE 23 IN constants.asm
                    > USED AT LINE 100 IN IOSerial.asm
                    > USED AT LINE 106 IN IOSerial.asm
                    > USED AT LINE 112 IN IOSerial.asm
                    > USED AT LINE 118 IN IOSerial.asm
                    > USED AT LINE 124 IN IOSerial.asm
                    > USED AT LINE 130 IN IOSerial.asm
                    > USED AT LINE 136 IN IOSerial.asm
                    > USED AT LINE 142 IN IOSerial.asm
                    > USED AT LINE 155 IN IOSerial.asm
                    > USED AT LINE 197 IN IOSerial.asm
                    > USED AT LINE 40 IN MAIN.asm
RAMSTART:           0800 DEFINED AT LINE 24 IN constants.asm
                    > USED AT LINE 6 IN ram.asm
ROMSIZE:            0800 DEFINED AT LINE 25 IN constants.asm
RAMSIZE:            0800 DEFINED AT LINE 26 IN constants.asm
CONTROL:            0080 DEFINED AT LINE 22 IN IOSerial.asm
                    > USED AT LINE 486 IN IOSerial.asm
                    > USED AT LINE 508 IN IOSerial.asm
STATUS:             0080 DEFINED AT LINE 23 IN IOSerial.asm
                    > USED AT LINE 306 IN IOSerial.asm
                    > USED AT LINE 319 IN IOSerial.asm
TDR:                0081 DEFINED AT LINE 24 IN IOSerial.asm
                    > USED AT LINE 311 IN IOSerial.asm
RDR:                0081 DEFINED AT LINE 25 IN IOSerial.asm
                    > USED AT LINE 323 IN IOSerial.asm
MRESET:             0003 DEFINED AT LINE 32 IN IOSerial.asm
                    > USED AT LINE 485 IN IOSerial.asm
DIV_64:             0002 DEFINED AT LINE 35 IN IOSerial.asm
                    > USED AT LINE 507 IN IOSerial.asm
F7E2:               0000 DEFINED AT LINE 39 IN IOSerial.asm
F7O2:               0004 DEFINED AT LINE 40 IN IOSerial.asm
F7E1:               0008 DEFINED AT LINE 41 IN IOSerial.asm
F7O1:               000C DEFINED AT LINE 42 IN IOSerial.asm
F8N2:               0010 DEFINED AT LINE 43 IN IOSerial.asm
                    > USED AT LINE 507 IN IOSerial.asm
F8N1:               0014 DEFINED AT LINE 44 IN IOSerial.asm
F8E1:               0018 DEFINED AT LINE 45 IN IOSerial.asm
F8O1:               001C DEFINED AT LINE 46 IN IOSerial.asm
RTSLID:             0000 DEFINED AT LINE 50 IN IOSerial.asm
                    > USED AT LINE 507 IN IOSerial.asm
RTSLIE:             0020 DEFINED AT LINE 51 IN IOSerial.asm
RTSHID:             0040 DEFINED AT LINE 52 IN IOSerial.asm
RTSLIDB:            0060 DEFINED AT LINE 53 IN IOSerial.asm
RIE:                0080 DEFINED AT LINE 57 IN IOSerial.asm
RDRF:               0000 DEFINED AT LINE 61 IN IOSerial.asm
TDRE:               0001 DEFINED AT LINE 62 IN IOSerial.asm
DCD:                0002 DEFINED AT LINE 63 IN IOSerial.asm
CTS:                0003 DEFINED AT LINE 64 IN IOSerial.asm
FE:                 0004 DEFINED AT LINE 65 IN IOSerial.asm
OVRN:               0005 DEFINED AT LINE 66 IN IOSerial.asm
PE:                 0006 DEFINED AT LINE 67 IN IOSerial.asm
IRQ:                0007 DEFINED AT LINE 68 IN IOSerial.asm
KEYBUF:             0000 DEFINED AT LINE 76 IN IOSerial.asm
SCAN:               0001 DEFINED AT LINE 77 IN IOSerial.asm
DISPLY:             0002 DEFINED AT LINE 78 IN IOSerial.asm
PORT3:              0003 DEFINED AT LINE 79 IN IOSerial.asm
PORT4:              0004 DEFINED AT LINE 80 IN IOSerial.asm
PORT5:              0005 DEFINED AT LINE 81 IN IOSerial.asm
PORT6:              0006 DEFINED AT LINE 82 IN IOSerial.asm
PORT7:              0007 DEFINED AT LINE 83 IN IOSerial.asm
ESC:                001B DEFINED AT LINE 96 IN IOSerial.asm
CR:                 000D DEFINED AT LINE 97 IN IOSerial.asm
LF:                 000A DEFINED AT LINE 98 IN IOSerial.asm
RSTVEC:             0000 DEFINED AT LINE 102 IN IOSerial.asm
RST1:               0003 DEFINED AT LINE 105 IN IOSerial.asm
RST2:               000E DEFINED AT LINE 111 IN IOSerial.asm
RST3:               0016 DEFINED AT LINE 117 IN IOSerial.asm
RST4:               001E DEFINED AT LINE 123 IN IOSerial.asm
RST5:               0026 DEFINED AT LINE 129 IN IOSerial.asm
RST6:               002E DEFINED AT LINE 135 IN IOSerial.asm
SEVENSEGMENT:       0040 DEFINED AT LINE 160 IN IOSerial.asm
PWRUP:              0050 DEFINED AT LINE 182 IN IOSerial.asm
                    > USED AT LINE 491 IN IOSerial.asm
BITIME:             0053 DEFINED AT LINE 184 IN IOSerial.asm
BITIM1:             0058 DEFINED AT LINE 188 IN IOSerial.asm
                    > USED AT LINE 190 IN IOSerial.asm
INTRET:             005F DEFINED AT LINE 193 IN IOSerial.asm
TXDATA:             006C DEFINED AT LINE 301 IN IOSerial.asm
                    > USED AT LINE 479 IN IOSerial.asm
TXCHAR:             006C DEFINED AT LINE 302 IN IOSerial.asm
TXCHAR1:            006E DEFINED AT LINE 305 IN IOSerial.asm
                    > USED AT LINE 309 IN IOSerial.asm
RXDATA:             0079 DEFINED AT LINE 317 IN IOSerial.asm
                    > USED AT LINE 477 IN IOSerial.asm
RXCHAR:             0079 DEFINED AT LINE 318 IN IOSerial.asm
                    > USED AT LINE 322 IN IOSerial.asm
GETCHAR:            0082 DEFINED AT LINE 442 IN IOSerial.asm
                    > USED AT LINE 161 IN MAIN.asm
PUTCHAR:            0086 DEFINED AT LINE 446 IN IOSerial.asm
                    > USED AT LINE 177 IN MAIN.asm
                    > USED AT LINE 319 IN MAIN.asm
                    > USED AT LINE 379 IN MAIN.asm
                    > USED AT LINE 408 IN MAIN.asm
                    > USED AT LINE 502 IN MAIN.asm
                    > USED AT LINE 517 IN MAIN.asm
                    > USED AT LINE 558 IN MAIN.asm
ISR:                008C DEFINED AT LINE 452 IN IOSerial.asm
                    > USED AT LINE 109 IN IOSerial.asm
                    > USED AT LINE 115 IN IOSerial.asm
                    > USED AT LINE 121 IN IOSerial.asm
                    > USED AT LINE 127 IN IOSerial.asm
                    > USED AT LINE 133 IN IOSerial.asm
                    > USED AT LINE 139 IN IOSerial.asm
                    > USED AT LINE 200 IN IOSerial.asm
RESET:              009F DEFINED AT LINE 475 IN IOSerial.asm
                    > USED AT LINE 103 IN IOSerial.asm
TRUE:               00-1 DEFINED AT LINE 13 IN MAIN.asm
                    > USED AT LINE 438 IN MAIN.asm
FALSE:              0000 DEFINED AT LINE 14 IN MAIN.asm
                    > USED AT LINE 434 IN MAIN.asm
UNLIMITED:          00-1 DEFINED AT LINE 15 IN MAIN.asm
CTRL_C:             0003 DEFINED AT LINE 17 IN MAIN.asm
                    > USED AT LINE 207 IN MAIN.asm
CTRL_H:             0008 DEFINED AT LINE 18 IN MAIN.asm
                    > USED AT LINE 168 IN MAIN.asm
BSLASH:             005C DEFINED AT LINE 20 IN MAIN.asm
IOPCODES:           0180 DEFINED AT LINE 42 IN MAIN.asm
                    > USED AT LINE 252 IN MAIN.asm
IALTCODES:          01AA DEFINED AT LINE 89 IN MAIN.asm
BACKSPACE:          01C6 DEFINED AT LINE 120 IN MAIN.asm
                    > USED AT LINE 169 IN MAIN.asm
START:              01D4 DEFINED AT LINE 129 IN MAIN.asm
                    > USED AT LINE 6
INTERPRET:          01E8 DEFINED AT LINE 135 IN MAIN.asm
                    > USED AT LINE 231 IN MAIN.asm
INTERPRET2:         01F2 DEFINED AT LINE 141 IN MAIN.asm
                    > USED AT LINE 123 IN MAIN.asm
                    > USED AT LINE 127 IN MAIN.asm
                    > USED AT LINE 170 IN MAIN.asm
INTERPRET3:         01FA DEFINED AT LINE 148 IN MAIN.asm
                    > USED AT LINE 157 IN MAIN.asm
INTERPRET4:         0200 DEFINED AT LINE 154 IN MAIN.asm
                    > USED AT LINE 146 IN MAIN.asm
WAITCHAR:           0205 DEFINED AT LINE 160 IN MAIN.asm
                    > USED AT LINE 179 IN MAIN.asm
                    > USED AT LINE 193 IN MAIN.asm
WAITCHAR1:          021A DEFINED AT LINE 172 IN MAIN.asm
                    > USED AT LINE 163 IN MAIN.asm
WAITCHAR3:          0228 DEFINED AT LINE 181 IN MAIN.asm
                    > USED AT LINE 167 IN MAIN.asm
WAITCHAR4:          023E DEFINED AT LINE 197 IN MAIN.asm
                    > USED AT LINE 165 IN MAIN.asm
NEXT:               0246 DEFINED AT LINE 202 IN MAIN.asm
                    > USED AT LINE 210 IN MAIN.asm
                    > USED AT LINE 235 IN MAIN.asm
EXIT:               025A DEFINED AT LINE 217 IN MAIN.asm
                    > USED AT LINE 206 IN MAIN.asm
ETX:                0264 DEFINED AT LINE 225 IN MAIN.asm
                    > USED AT LINE 208 IN MAIN.asm
ETX1:               026D DEFINED AT LINE 230 IN MAIN.asm
                    > USED AT LINE 228 IN MAIN.asm
INIT:               0270 DEFINED AT LINE 233 IN MAIN.asm
                    > USED AT LINE 131 IN MAIN.asm
INITOPS:            0297 DEFINED AT LINE 251 IN MAIN.asm
INITOPS1:           02A0 DEFINED AT LINE 256 IN MAIN.asm
                    > USED AT LINE 266 IN MAIN.asm
                    > USED AT LINE 277 IN MAIN.asm
INITOPS2:           02B0 DEFINED AT LINE 268 IN MAIN.asm
                    > USED AT LINE 261 IN MAIN.asm
INITOPS2A:          02B5 DEFINED AT LINE 273 IN MAIN.asm
                    > USED AT LINE 276 IN MAIN.asm
LOOKUPREF0:         02BB DEFINED AT LINE 279 IN MAIN.asm
LOOKUPREF:          02C2 DEFINED AT LINE 283 IN MAIN.asm
LOOKUPREF1:         02C4 DEFINED AT LINE 285 IN MAIN.asm
                    > USED AT LINE 282 IN MAIN.asm
PRINTHEX:           02CE DEFINED AT LINE 296 IN MAIN.asm
PRINTHEX2:          02D9 DEFINED AT LINE 305 IN MAIN.asm
                    > USED AT LINE 300 IN MAIN.asm
                    > USED AT LINE 302 IN MAIN.asm
PRINTHEX3:          02E2 DEFINED AT LINE 313 IN MAIN.asm
                    > USED AT LINE 311 IN MAIN.asm
NESTING:            02ED DEFINED AT LINE 331 IN MAIN.asm
                    > USED AT LINE 152 IN MAIN.asm
                    > USED AT LINE 178 IN MAIN.asm
NESTING1:           02F6 DEFINED AT LINE 338 IN MAIN.asm
                    > USED AT LINE 333 IN MAIN.asm
NESTING2:           0305 DEFINED AT LINE 347 IN MAIN.asm
                    > USED AT LINE 342 IN MAIN.asm
                    > USED AT LINE 344 IN MAIN.asm
NESTING3:           0307 DEFINED AT LINE 350 IN MAIN.asm
                    > USED AT LINE 346 IN MAIN.asm
NESTING4:           0312 DEFINED AT LINE 357 IN MAIN.asm
                    > USED AT LINE 352 IN MAIN.asm
                    > USED AT LINE 354 IN MAIN.asm
PROMPT:             0314 DEFINED AT LINE 361 IN MAIN.asm
                    > USED AT LINE 136 IN MAIN.asm
CRLF:               031D DEFINED AT LINE 366 IN MAIN.asm
                    > USED AT LINE 190 IN MAIN.asm
PRINTSTR:           0324 DEFINED AT LINE 371 IN MAIN.asm
                    > USED AT LINE 125 IN MAIN.asm
                    > USED AT LINE 132 IN MAIN.asm
                    > USED AT LINE 362 IN MAIN.asm
                    > USED AT LINE 367 IN MAIN.asm
PUTSTR0:            032B DEFINED AT LINE 378 IN MAIN.asm
                    > USED AT LINE 384 IN MAIN.asm
PUTSTR:             032F DEFINED AT LINE 381 IN MAIN.asm
                    > USED AT LINE 373 IN MAIN.asm
RPUSH:              0334 DEFINED AT LINE 387 IN MAIN.asm
                    > USED AT LINE 412 IN MAIN.asm
RPOP:               0341 DEFINED AT LINE 396 IN MAIN.asm
                    > USED AT LINE 220 IN MAIN.asm
WRITECHAR:          034E DEFINED AT LINE 405 IN MAIN.asm
ENTER:              0353 DEFINED AT LINE 410 IN MAIN.asm
                    > USED AT LINE 464 IN IOSerial.asm
CARRY:              035C DEFINED AT LINE 417 IN MAIN.asm
SETBYTEMODE:        0366 DEFINED AT LINE 423 IN MAIN.asm
RESETBYTEMODE:      036A DEFINED AT LINE 426 IN MAIN.asm
ASSIGNBYTEMODE:     036B DEFINED AT LINE 428 IN MAIN.asm
                    > USED AT LINE 425 IN MAIN.asm
FALSE_:             0373 DEFINED AT LINE 433 IN MAIN.asm
                    > USED AT LINE 497 IN MAIN.asm
TRUE_:              0378 DEFINED AT LINE 437 IN MAIN.asm
                    > USED AT LINE 506 IN MAIN.asm
TRUE1:              037B DEFINED AT LINE 439 IN MAIN.asm
                    > USED AT LINE 435 IN MAIN.asm
PAGE4:              0400 DEFINED AT LINE 447 IN MAIN.asm
QUOTE_:             0400 DEFINED AT LINE 449 IN MAIN.asm
AT_:                0400 DEFINED AT LINE 450 IN MAIN.asm
UNDERSCORE_:        0400 DEFINED AT LINE 451 IN MAIN.asm
BSLASH_:            0400 DEFINED AT LINE 452 IN MAIN.asm
VAR_:               0400 DEFINED AT LINE 453 IN MAIN.asm
BANG_:              0400 DEFINED AT LINE 454 IN MAIN.asm
AMPER_:             0400 DEFINED AT LINE 455 IN MAIN.asm
PIPE_:              0400 DEFINED AT LINE 456 IN MAIN.asm
CARET_:             0400 DEFINED AT LINE 457 IN MAIN.asm
TILDE_:             0400 DEFINED AT LINE 458 IN MAIN.asm
PLUS_:              0400 DEFINED AT LINE 459 IN MAIN.asm
CALL_:              0400 DEFINED AT LINE 460 IN MAIN.asm
DOT_:               0400 DEFINED AT LINE 461 IN MAIN.asm
COMMA_:             0400 DEFINED AT LINE 462 IN MAIN.asm
DQUOTE_:            0400 DEFINED AT LINE 463 IN MAIN.asm
EQ_:                0400 DEFINED AT LINE 464 IN MAIN.asm
PERCENT_:           0400 DEFINED AT LINE 465 IN MAIN.asm
SEMI_:              0400 DEFINED AT LINE 466 IN MAIN.asm
GT_:                0400 DEFINED AT LINE 467 IN MAIN.asm
LBRACE_:            0400 DEFINED AT LINE 468 IN MAIN.asm
RBRACE_:            0400 DEFINED AT LINE 469 IN MAIN.asm
LT_:                0400 DEFINED AT LINE 470 IN MAIN.asm
DOLLAR_:            0400 DEFINED AT LINE 471 IN MAIN.asm
MINUS_:             0400 DEFINED AT LINE 472 IN MAIN.asm
GRAVE_:             0400 DEFINED AT LINE 473 IN MAIN.asm
LBRACK_:            0400 DEFINED AT LINE 474 IN MAIN.asm
NUM_:               0400 DEFINED AT LINE 475 IN MAIN.asm
RPAREN_:            0400 DEFINED AT LINE 476 IN MAIN.asm
RBRACK_:            0400 DEFINED AT LINE 477 IN MAIN.asm
COLON_:             0400 DEFINED AT LINE 478 IN MAIN.asm
LPAREN_:            0400 DEFINED AT LINE 479 IN MAIN.asm
QUESTION_:          0400 DEFINED AT LINE 480 IN MAIN.asm
HASH_:              0400 DEFINED AT LINE 481 IN MAIN.asm
STAR_:              0400 DEFINED AT LINE 482 IN MAIN.asm
SLASH_:             0400 DEFINED AT LINE 483 IN MAIN.asm
ALT_:               0400 DEFINED AT LINE 484 IN MAIN.asm
PAGE6:              0500 DEFINED AT LINE 491 IN MAIN.asm
ANOP_:              0500 DEFINED AT LINE 493 IN MAIN.asm
FALSEX_:            0502 DEFINED AT LINE 496 IN MAIN.asm
PRINTCHAR_:         0505 DEFINED AT LINE 499 IN MAIN.asm
TRUEX_:             050C DEFINED AT LINE 505 IN MAIN.asm
PRINTDEC:           050F DEFINED AT LINE 513 IN MAIN.asm
PRINTDEC2:          051E DEFINED AT LINE 524 IN MAIN.asm
                    > USED AT LINE 515 IN MAIN.asm
PRINTDEC4:          0540 DEFINED AT LINE 540 IN MAIN.asm
                    > USED AT LINE 528 IN MAIN.asm
                    > USED AT LINE 530 IN MAIN.asm
                    > USED AT LINE 532 IN MAIN.asm
                    > USED AT LINE 534 IN MAIN.asm
                    > USED AT LINE 537 IN MAIN.asm
PRINTDEC5:          0542 DEFINED AT LINE 542 IN MAIN.asm
                    > USED AT LINE 545 IN MAIN.asm
PRINTDEC6:          0552 DEFINED AT LINE 554 IN MAIN.asm
                    > USED AT LINE 549 IN MAIN.asm
PRINTDEC7:          0553 DEFINED AT LINE 556 IN MAIN.asm
                    > USED AT LINE 553 IN MAIN.asm
NUM:                0557 DEFINED AT LINE 564 IN MAIN.asm
NUM0:               0560 DEFINED AT LINE 570 IN MAIN.asm
                    > USED AT LINE 568 IN MAIN.asm
NUM1:               0561 DEFINED AT LINE 572 IN MAIN.asm
                    > USED AT LINE 589 IN MAIN.asm
NUM2:               0579 DEFINED AT LINE 590 IN MAIN.asm
                    > USED AT LINE 575 IN MAIN.asm
                    > USED AT LINE 577 IN MAIN.asm
NUM3:               0584 DEFINED AT LINE 598 IN MAIN.asm
                    > USED AT LINE 593 IN MAIN.asm
DSIZE:              0080 DEFINED AT LINE 1 IN ram.asm
                    > USED AT LINE 13 IN ram.asm
RSIZE:              0080 DEFINED AT LINE 2 IN ram.asm
                    > USED AT LINE 10 IN ram.asm
TIBSIZE:            0100 DEFINED AT LINE 3 IN ram.asm
                    > USED AT LINE 8 IN ram.asm
VARS_SIZE:          0034 DEFINED AT LINE 4 IN ram.asm
                    > USED AT LINE 241 IN MAIN.asm
                    > USED AT LINE 40 IN ram.asm
                    > USED AT LINE 41 IN ram.asm
TIB:                0800 DEFINED AT LINE 8 IN ram.asm
                    > USED AT LINE 145 IN MAIN.asm
                    > USED AT LINE 173 IN MAIN.asm
                    > USED AT LINE 182 IN MAIN.asm
                    > USED AT LINE 199 IN MAIN.asm
RSTACK:             0980 DEFINED AT LINE 11 IN ram.asm
                    > USED AT LINE 234 IN MAIN.asm
DSTACK:             0A00 DEFINED AT LINE 14 IN ram.asm
                    > USED AT LINE 130 IN MAIN.asm
                    > USED AT LINE 226 IN MAIN.asm
                    > USED AT LINE 229 IN MAIN.asm
                    > USED AT LINE 244 IN MAIN.asm
STACK:              0A00 DEFINED AT LINE 15 IN ram.asm
                    > USED AT LINE 476 IN IOSerial.asm
TBPTR:              0A00 DEFINED AT LINE 16 IN ram.asm
VTEMP1:             0A02 DEFINED AT LINE 17 IN ram.asm
VTEMP2:             0A04 DEFINED AT LINE 18 IN ram.asm
RST08:              0A06 DEFINED AT LINE 20 IN ram.asm
RST10:              0A08 DEFINED AT LINE 21 IN ram.asm
RST18:              0A0A DEFINED AT LINE 22 IN ram.asm
RST20:              0A0C DEFINED AT LINE 23 IN ram.asm
RST28:              0A0E DEFINED AT LINE 24 IN ram.asm
RST30:              0A10 DEFINED AT LINE 25 IN ram.asm
BAUD:               0A12 DEFINED AT LINE 26 IN ram.asm
INTVEC:             0A14 DEFINED AT LINE 27 IN ram.asm
NMIVEC:             0A16 DEFINED AT LINE 28 IN ram.asm
GETCVEC:            0A18 DEFINED AT LINE 29 IN ram.asm
                    > USED AT LINE 443 IN IOSerial.asm
                    > USED AT LINE 478 IN IOSerial.asm
PUTCVEC:            0A1A DEFINED AT LINE 30 IN ram.asm
                    > USED AT LINE 448 IN IOSerial.asm
                    > USED AT LINE 480 IN IOSerial.asm
OPCODES:            0B00 DEFINED AT LINE 33 IN ram.asm
                    > USED AT LINE 253 IN MAIN.asm
ALTCODES:           0B5E DEFINED AT LINE 35 IN ram.asm
VARS:               0C00 DEFINED AT LINE 40 IN ram.asm
                    > USED AT LINE 237 IN MAIN.asm
DEFS:               0C34 DEFINED AT LINE 41 IN ram.asm
                    > USED AT LINE 280 IN MAIN.asm
ALTVARS:            0C68 DEFINED AT LINE 43 IN ram.asm
VBYTEMODE:          0C6A DEFINED AT LINE 45 IN ram.asm
                    > USED AT LINE 429 IN MAIN.asm
                    > USED AT LINE 430 IN MAIN.asm
VCARRY:             0C6C DEFINED AT LINE 46 IN ram.asm
                    > USED AT LINE 420 IN MAIN.asm
VINTFUNC:           0C72 DEFINED AT LINE 49 IN ram.asm
VHEAPPTR:           0C76 DEFINED AT LINE 51 IN ram.asm
                    > USED AT LINE 249 IN MAIN.asm
VTIBPTR:            0C7C DEFINED AT LINE 54 IN ram.asm
                    > USED AT LINE 139 IN MAIN.asm
                    > USED AT LINE 198 IN MAIN.asm
VREMAIN:            0C8A DEFINED AT LINE 61 IN ram.asm
VSTKSTART:          0C8C DEFINED AT LINE 62 IN ram.asm
                    > USED AT LINE 245 IN MAIN.asm
VINTID:             0C92 DEFINED AT LINE 65 IN ram.asm
                    > USED AT LINE 462 IN IOSerial.asm
VLASTDEF:           0C9A DEFINED AT LINE 69 IN ram.asm
                    > USED AT LINE 247 IN MAIN.asm
VPOINTER:           0C9C DEFINED AT LINE 71 IN ram.asm
VELSE:              0C9E DEFINED AT LINE 72 IN ram.asm
HEAP:               0CA0 DEFINED AT LINE 74 IN ram.asm
                    > USED AT LINE 248 IN MAIN.asm
